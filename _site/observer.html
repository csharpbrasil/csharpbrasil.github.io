<!DOCTYPE html>
<html>

<head>
	<!-- Meta -->
	<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="C# Brasil">

	<title>Observer</title>

	<!-- CSS & fonts -->
	<link rel="stylesheet" href="/css/main.css?1716937206294534819">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,300,600,800" rel="stylesheet" type="text/css">

    <link rel="shortcut icon" href="/images/favicon.png" />
</head>


<body>
	<div id="wrap">
	  	
    <!-- Navigation -->
    <nav id="nav">
	<div id="nav-list">
		<a href="http://localhost:4000/">Página inicial</a>
		<a href="http://localhost:4000/sobre">Sobre o blog</a>
	</div>
</nav>

    
    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>
    <!-- Header -->
    <header id="header">
	<a href="http://localhost:4000/">
		<img src="/images/logo_csharpbrasil.png" class="logo" alt="C# Brasil">
	</a>
</header>

    <!-- Main content -->
	  <div id="container">
      <main>
        <article id="post-page">
	<h2>Observer</h2>		
	<time datetime="2010-05-04T21:46:10-03:00" class="by-line">
		
		4
		Maio
		  
		2010
	</time>
	<div class="content">

		<p>Antes de falar do Observer é necessário entender o que é Design Pattern, ou padrão de desenho de software, eles descrevem soluções para problemas recorrentes no desenvolvimento de sistemas que utilizam a O.O. - Orientação a Objetos. Um padrão define um problema, a solução deste problema, a situação onde aplicar esta solução e suas conseqüências e o nome deste.</p>

<p>Designs Patterns visam facilitar a reutilização de código, também apresentam um vocabulário comum de desenho facilitando comunicação, documentação e aprendizado dos sistemas.</p>

<p>Agora sim vamos falar um pouco de um dos padrões, o Observer é um Design Pattern, traduzindo é um padrão de desenvolvimento que representa uma relação de 1-N (de um para muitos) entre objetos. Assim quando um objeto muda de estado os objetos dependentes serão notificados/informados e atualizados automaticamente. Este padrão permite que objetos sejam avisados da mudança de estado de outros eventos ocorrendo num outro objeto.</p>

<p>Observer é também chamado de Publisher-Subscriber, Event Generator e Dependents.</p>

<p>As classes participantes e/ou objetos participantes deste padrão são:</p>

<ol>
  <li>Subject (Stock) - Conhece os Observers. Qualquer número de objetos Observer pode observar um Subject. - Fornece interfaces para anexar e desanexar objetos Observer.</li>
  <li>ConcreteSubject (IBM) - Armazena estado de interesse para o ConcreteObserver. - Envia a notificação para os observers quando o status muda.</li>
  <li>Observer (IInvestor) - Define uma interface de atualização para objetos que devem ser notificados de mudanças em um Subject.</li>
  <li>ConcreteObserver(Investor) - Mantém uma referência a um objeto ConcreteSubject. - Armazena o estado que deve ficar consistente com o Subject. - Implementa a interface Observer atualizando para manter o estado consistente com o Subject.</li>
</ol>

<p>Para esta demonstração utilizarei como linguagem de programação C#, e como ferramenta de compilação e testes o Visual Studio 2008 com o .Net Framework 3.5. Apenas pra deixar clara a forma que foi construída. Neste post você poderá também efetuar o download do projeto e fazer os testes e alterações que desejar.</p>

<p>Em um projeto WindowsForms mesmo, para apresentação do funcionamento, crio a seguinte classe que desempenhará o papel do Subject:</p>

<p>[code=’csharp’] public abstract class Stock { private string m_symbol; private double m_price; private List m_investors = new List(); public Stock(string symbol, double price) { this.m_symbol = symbol; this.m_price = price; } public void Attach(IInvestor investor) { m_investors.Add(investor); } public void Detach(IInvestor investor) { m_investors.Remove(investor); } public void Notify() { foreach (IInvestor investor in m_investors) investor.Update(this); } public double Price { get { return m_price; } set { if (m_price != value) { m_price = value; Notify(); } } } public string Symbol { get { return m_symbol; } } } [/code]</p>

<p>Em seguida adiciono uma nova classe que herda da classe abstrata criada, esta desempenhará o papel da ConcreteSubject.</p>

<p>[code=’csharp’] public class IBM : Stock { public IBM(string symbol, double price) : base(symbol, price) { } } [/code]</p>

<p>A próxima classe a ser inserida é classe que desempenhará o papel do observer, ela é uma interface:</p>

<p>[code=’csharp’] public interface IInvestor { void Update(Stock stock); } [/code]</p>

<p>Por fim adiciono a classe Investor que desempenha o papel do ConcreteObserver, herdando portanto da interface criada.</p>

<p>[code=’csharp’] public class Investor : IInvestor { private string m_name; private Stock m_stock; public Investor(string name) { this.m_name = name; } public void Update(Stock stock) { MessageBox.Show(“Notificação: (“ + m_name + “) de “ + stock.Symbol + “.O preço foi alterado para “ + stock.Price.ToString(“0.00”)); } public Stock Stock { get { return m_stock; } set { m_stock = value; } } } [/code]</p>

<p>Com isso já é possível utilizar a estrutura para os devidos testes.</p>

<p>Como o projeto criado é do tipo WindowsForms no evento load do formulário incluo o seguinte código:</p>

<p>[code=’csharp’] private void Form1_Load(object sender, EventArgs e) { IBM ibm = new IBM(“IBM”, 100.00); ibm.Attach(new Investor(“Acionista A”)); ibm.Attach(new Investor(“Acionista B”)); /* depois de ter realizado o Attach, a cada vez que atribuir um novo preço para ibm, cada um dos investidores será notificado. */ ibm.Price = 200.10; ibm.Price = 500.00; this.Close(); } [/code]</p>

<p>Pronto! Agora é só compilar, adicionar as devidas referências que por ventura possam estar faltando. E o resultado será 4 MessagesBox, pois para cada alteração de preço, existe 2 Investor para serem notificados.</p>

<p>As mensagens apresentadas serão como as Figuras 1,2,3 e 4 apresentadas abaixo:</p>

<p><img src="https://raphaelcardoso.com.br/wp-content/uploads/2010/05/observer_0001-1.gif" alt="" title="observer_0001" /><br />
<img src="https://raphaelcardoso.com.br/wp-content/uploads/2010/05/observer_0002-1.gif" alt="" title="observer_0002" /><br />
<img src="https://raphaelcardoso.com.br/wp-content/uploads/2010/05/observer_0003-1.gif" alt="" title="observer_0003" /><br />
<img src="https://raphaelcardoso.com.br/wp-content/uploads/2010/05/observer_0004-1.gif" alt="" title="observer_0004" /></p>

<p>Apresentando como fica a estrutura dos arquivos em Solution Explorer:</p>

<p><img src="https://raphaelcardoso.com.br/wp-content/uploads/2010/05/observer_0005-1.gif" alt="" title="observer_0005" /></p>

<p>E como dito anteriormente segue em anexo o arquivo compactado com a solução para baixar, e ajudar no entendimento.</p>

<p>Download Fonte <a href="https://raphaelcardoso.com.br/wp-content/uploads/2010/05/Observer-1.zip">aqui</a></p>

		
	</div>
</article>


      </main>		
      <!-- Pagination links -->
      
	  </div>
    
    <!-- Footer -->
    <footer class="footer"><span>&copy; 2024 C# Brasil. Todos os direitos reservados | Versão: 1.0.0 </span></footer>
    <!-- Script -->
    <script src="/js/main.js"></script>	

	</div>
</body>
</html>
