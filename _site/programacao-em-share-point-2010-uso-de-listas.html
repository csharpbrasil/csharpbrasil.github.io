<!DOCTYPE html>
<html>

<head>
	<!-- Meta -->
	<meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="C# Brasil">

	<title>Programação em Share Point 2010 - Uso de Listas</title>

	<!-- CSS & fonts -->
	<link rel="stylesheet" href="/css/main.css?1716937206294534819">
    <link href="https://fonts.googleapis.com/css?family=Open+Sans:400,300,600,800" rel="stylesheet" type="text/css">

    <link rel="shortcut icon" href="/images/favicon.png" />
</head>


<body>
	<div id="wrap">
	  	
    <!-- Navigation -->
    <nav id="nav">
	<div id="nav-list">
		<a href="http://localhost:4000/">Página inicial</a>
		<a href="http://localhost:4000/sobre">Sobre o blog</a>
	</div>
</nav>

    
    <!-- Icon menu -->
	  <a id="nav-menu">
	  	<div id="menu"></div>
	  </a>
    <!-- Header -->
    <header id="header">
	<a href="http://localhost:4000/">
		<img src="/images/logo_csharpbrasil.png" class="logo" alt="C# Brasil">
	</a>
</header>

    <!-- Main content -->
	  <div id="container">
      <main>
        <article id="post-page">
	<h2>Programação em Share Point 2010 - Uso de Listas</h2>		
	<time datetime="2013-02-07T16:48:46-02:00" class="by-line">
		
		7
		Fevereiro
		  
		2013
	</time>
	<div class="content">

		<p>Vamos discorrer um pouco sobre programação sobre Share Point, e falar informações importantes sobre este assunto.</p>

<p>O procedimento que abordarei aqui vale tanto para programação utilizando a Classe ClientContext como a <em>SPClientContext</em>.</p>

<p>No popular, significando que vale tanto para implementar um WebPart como aplicação Cliente consumindo o Share Point.</p>

<p>Utilizarei a seguinte metodologia:</p>

<p>Segue um exemplo simples de acesso, onde estarei comentando item a item sobre o mesmo.</p>

<p>[sourcecode language=’csharp’] using (ctx) { try { if (ctx != null) { List Lista = ctx.Web.Lists.GetById(new Guid(“{173139CB-4AEFE-4002-9EE2-C411BD64CEAF}”)); ctx.Load(Lista); ctx.ExecuteQuery(); CamlQuery query = new CamlQuery(); query.ViewXml = “”; ListItemCollection collListItem = Lista.GetItems(query); ctx.Load(collListItem); ctx.ExecuteQuery(); int jobnro = 0; foreach (ListItem item in collListItem) { jobnro++; String Id = item[“ID”].ToString(); } } } catch (Exception e) { MessageBox.Show(“Erro na visualização da lista - “ + e.Message); } } [/sourcecode]</p>

<p>O ctx é na verdade a conexão com o Share Point, obtendo-se pela classe ClientContext.</p>

<p>O processo de Conexão com o ClientContext (ctx), foge do escopo deste tópico e pode ser facilmente encontrado em outros lugares.</p>

<p>O importante, e quando dito parece lógico, mas deve sempre ser mencionado.</p>

<p>A normalização da Microsoft, diz que Colletion é quando estamos mencionando mais de um elemento, exemplo “Coleção de Listas do Site”, ou “Coleção de Itens de uma Lista”.</p>

<p>Existem 4 (quatro) classes para gerenciamento de listas.</p>

<ol>
  <li>ListColletion</li>
  <li>List</li>
  <li>ListItemCollection</li>
  <li>ListItem</li>
</ol>

<p>A Classe ListColletion é a coleção de listas de um site, e pode ser obtida através do ClientContext ou SPClientContext, conforme forma de acesso que esta em uso, exemplo:</p>

<p>Se você possui 3 listas (apontamentos, tarefas, agenda), ao instanciar as listas em um objeto ListColletion, o mesmo pegara todas as Listas dela.</p>

<p>Desta forma é possível pesquisar e averiguar qual lista é realmente aquela que se deseja obter.</p>

<p>Uma forma comum de obter esta classe é através da referencia direta das propriedades da classe ClientContext, exemplo: <em>ctx.Web.Lists (ListColletion)</em></p>

<p>[sourcecode language=’csharp’] List Lista = ctx.Web.Lists.GetById(new Guid(“{173139CB-4AEFE-4002-9EE2-C411BD64CEAF}”)); [/sourcecode]</p>

<p>No exemplo acima, pesquisamos se o site possui uma lista especifica.</p>

<p>A classe List contem as informações sobre uma determinada lista, informando entre varias informações o <em>Guid</em> (Uma especie de Chave identificadora) da lista.</p>

<p>Tambem são informações da lista, campos, descrição e informações que detalhem a lista como um todo.</p>

<p>As informações dos elementos da lista são obtidas através da propriedade  <em>GetItems</em>.</p>

<p>Um mecanismo muito interessante que ai deve ser aferido, é que como o volume de elementos pode ser muito grande, é importante filtrar os elementos, resgatando apenas o conjunto de itens que se deseja. Isso é realizado por um mecanismo similar ao SQL. O <em>CamlQuery</em> foi a forma encontrada para se realizar esta pesquisa. A sua sintaxe, é bem complexa, mas é de forma geral um mix entre comandos sql e xml.</p>

<p>[sourcecode language=’csharp’] CamlQuery query = new CamlQuery(); query.ViewXml = “”; ListItemCollection collListItem = Lista.GetItems(query) [/sourcecode]</p>

<p>No exemplo acima, estamos pegando todos os itens e coletando na coleção de itens da lista (<em>ListItemCollection</em>).</p>

<p>Ao instanciar o ListItemColletion, tem-se na verdade não a lista mas o conjunto de dados da lista, ou seja, neste caso tem-se a relação de elementos da lista. Com a coleção desta lista, é possível através de um <em>foreach</em> os elementos individuais.</p>

<p>Para acessar a informação individual utilizamos o artificio de programação:</p>

<p>[sourcecode language=’csharp’] foreach (ListItem item in collListItem) { jobnro++; String Id = item[“ID”].ToString(); } [/sourcecode]</p>

<p>No caso pegamos os “registros” encontrados no collListItem (<em>ListItemCollection</em>) e trabalhamos com estes registros. Um a um, ou registro por registro.</p>

<p>A forma de acessar a informação do item é muito simples, podendo chamar o nome do campo, assim como faríamos tradicionalmente.</p>

		
	</div>
</article>


      </main>		
      <!-- Pagination links -->
      
	  </div>
    
    <!-- Footer -->
    <footer class="footer"><span>&copy; 2024 C# Brasil. Todos os direitos reservados | Versão: 1.0.0 </span></footer>
    <!-- Script -->
    <script src="/js/main.js"></script>	

	</div>
</body>
</html>
